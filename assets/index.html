<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CodeWebway</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #131313; color: #ddd; font-family: ui-sans-serif, -apple-system, Segoe UI, sans-serif; height: 100vh; }
    #login {
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      background: radial-gradient(circle at top, #2a2a2a, #111 70%);
    }
    .card {
      width: 100%;
      max-width: 460px;
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid #3f3f3f;
      border-radius: 12px;
      padding: 22px;
    }
    .card h1 { font-size: 20px; margin-bottom: 8px; }
    .card p { color: #aaa; margin-bottom: 14px; font-size: 14px; }
    .stack { display: flex; flex-direction: column; gap: 10px; }
    .row { display: flex; gap: 8px; }
    input {
      width: 100%;
      background: #111;
      border: 1px solid #444;
      color: #eee;
      border-radius: 8px;
      padding: 10px 12px;
      font-size: 14px;
      outline: none;
    }
    button {
      border: 1px solid #4f4f4f;
      border-radius: 8px;
      background: #2f65ff;
      color: #fff;
      padding: 10px 12px;
      font-size: 13px;
      cursor: pointer;
    }
    button:disabled { opacity: 0.6; cursor: wait; }
    .ghost { background: #2d2d2d; }
    #error { color: #ff8a80; margin-top: 10px; min-height: 20px; font-size: 13px; }

    #app { display: none; height: 100vh; flex-direction: column; }
    #topbar {
      border-bottom: 1px solid #2f2f2f;
      background: #1b1b1b;
      color: #c8c8c8;
      font-family: monospace;
      font-size: 12px;
      padding: 6px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    #topbar-right {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #usage {
      color: #9ad1ff;
      font-size: 11px;
    }
    #workspace { flex: 1; display: flex; min-height: 0; }
    #files {
      width: 34%;
      min-width: 260px;
      border-right: 1px solid #2f2f2f;
      display: flex;
      flex-direction: column;
      min-height: 0;
      background: #171717;
    }
    #file-head {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      padding: 8px;
      border-bottom: 1px solid #2f2f2f;
    }
    #tree { flex: 1; overflow: auto; padding: 8px; border-bottom: 1px solid #2f2f2f; }
    #preview-tabs {
      display: flex;
      gap: 6px;
      overflow-x: auto;
      padding: 8px;
      border-bottom: 1px solid #2f2f2f;
    }
    #preview {
      flex: 1;
      overflow: auto;
      padding: 10px;
      font-family: ui-monospace, Menlo, monospace;
      white-space: pre;
      font-size: 12px;
      color: #ddd;
    }
    #editor-actions {
      display: flex;
      gap: 8px;
      padding: 8px;
      border-bottom: 1px solid #2f2f2f;
      background: #151515;
    }
    #editor {
      display: none;
      flex: 1;
      min-height: 140px;
      width: 100%;
      resize: vertical;
      background: #111;
      color: #e5e5e5;
      border: 0;
      border-top: 1px solid #2f2f2f;
      padding: 10px;
      font-family: ui-monospace, Menlo, monospace;
      font-size: 12px;
      line-height: 1.4;
      outline: none;
    }
    .tree-item {
      padding: 4px 6px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-family: ui-monospace, Menlo, monospace;
      white-space: pre;
    }
    .tree-item:hover { background: #222; }
    .tree-item.active { background: #2b2b2b; }
    .indent { margin-left: 8px; }

    #terms { flex: 1; display: flex; flex-direction: column; min-height: 0; }
    #term-tabs {
      display: flex;
      gap: 8px;
      align-items: center;
      overflow-x: auto;
      border-bottom: 1px solid #2f2f2f;
      padding: 8px;
      background: #161616;
    }
    .tab {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 7px;
      border: 1px solid #383838;
      background: #232323;
      cursor: pointer;
      font-size: 12px;
      white-space: nowrap;
    }
    .tab.active { border-color: #2f65ff; }
    .tab button {
      padding: 2px 6px;
      background: #3a3a3a;
      border-color: #575757;
      font-size: 11px;
    }
    .preview-tab {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      border-radius: 7px;
      border: 1px solid #383838;
      background: #232323;
      font-size: 12px;
      white-space: nowrap;
    }
    .preview-tab.active { border-color: #2f65ff; }
    .preview-tab .label {
      background: transparent;
      border: 0;
      color: #ddd;
      padding: 0;
      font-size: 12px;
    }
    .preview-tab .close {
      padding: 2px 6px;
      font-size: 11px;
      background: #3a3a3a;
      border: 1px solid #575757;
      border-radius: 6px;
      color: #fff;
    }
    #terminal { flex: 1; min-height: 0; padding: 6px; }
  </style>
</head>
<body>
  <div id="login">
    <form class="card" id="login-form">
      <h1>CodeWebway</h1>
      <p>Enter password and PIN to open workspace</p>
      <div class="stack">
        <input id="password" type="password" autocomplete="current-password" placeholder="Password" required />
        <div class="row">
          <input id="pin" type="password" autocomplete="one-time-code" placeholder="PIN" />
          <button id="submit" type="submit">Connect</button>
        </div>
      </div>
      <div id="error"></div>
    </form>
  </div>

  <div id="app">
    <div id="topbar">
      <div id="status">Connected</div>
      <div id="topbar-right">
        <span id="usage">Today 0 B | Session 0 B</span>
        <button id="logout" class="ghost" type="button">Logout</button>
      </div>
    </div>
    <div id="workspace">
      <section id="files">
        <div id="file-head">
          <strong>Files</strong>
          <div class="row">
            <button id="refresh-tree" class="ghost" type="button">Refresh</button>
            <button id="open-shell-here" class="ghost" type="button">Open Shell Here</button>
          </div>
        </div>
        <div id="tree"></div>
        <div id="preview-tabs"></div>
        <div id="editor-actions">
          <button id="edit-file" class="ghost" type="button">Edit</button>
          <button id="save-file" type="button">Save</button>
          <button id="cancel-edit" class="ghost" type="button">Cancel</button>
        </div>
        <pre id="preview">Select a file to preview</pre>
        <textarea id="editor" spellcheck="false"></textarea>
      </section>
      <section id="terms">
        <div id="term-tabs">
          <button id="new-tab" type="button">+ New Tab</button>
        </div>
        <div id="terminal"></div>
      </section>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
  <script>
    const app = document.getElementById('app');
    const login = document.getElementById('login');
    const form = document.getElementById('login-form');
    const passwordInput = document.getElementById('password');
    const pinInput = document.getElementById('pin');
    const submitBtn = document.getElementById('submit');
    const errorEl = document.getElementById('error');
    const statusEl = document.getElementById('status');
    const usageEl = document.getElementById('usage');
    const logoutBtn = document.getElementById('logout');
    const newTabBtn = document.getElementById('new-tab');
    const termTabs = document.getElementById('term-tabs');
    const treeEl = document.getElementById('tree');
    const previewTabsEl = document.getElementById('preview-tabs');
    const previewEl = document.getElementById('preview');
    const editorEl = document.getElementById('editor');
    const editFileBtn = document.getElementById('edit-file');
    const saveFileBtn = document.getElementById('save-file');
    const cancelEditBtn = document.getElementById('cancel-edit');
    const openShellHereBtn = document.getElementById('open-shell-here');
    const refreshTreeBtn = document.getElementById('refresh-tree');

    let ws;
    let retries = 0;
    let wsConnectionId = 0;
    let term;
    let fitAddon;
    let loggingOut = false;
    let logoutNotice = '';

    let terminals = [];
    let activeTerminalId = null;
    let selectedDir = '.';
    const expandedDirs = new Set(['.']);

    const openFiles = [];
    let activeFilePath = null;
    let editingPath = null;
    let editingBaseHash = null;
    let editingOriginal = '';
    let usageTimer = null;
    const fileMeta = new Map();
    const FILE_WARN_BYTES = 128 * 1024;
    const FILE_EDIT_LIMIT_BYTES = 512 * 1024;
    const CACHE_PREFIX = 'rwtty:file:';
    const TERM_CACHE_PREFIX = 'cw:term:';
    const TERM_CACHE_MAX_CHARS = 500000;
    const terminalCache = new Map();
    const textDecoder = new TextDecoder();

    function setStatus(text, color) {
      statusEl.textContent = text;
      statusEl.style.color = color || '#c8c8c8';
    }

    async function api(path, options = {}) {
      const res = await fetch(path, options);
      return res;
    }

    function formatBytes(bytes) {
      if (bytes < 1024) return `${bytes} B`;
      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
      return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    }

    async function refreshUsage() {
      try {
        const res = await api('/api/usage');
        if (!res.ok) return;
        const data = await res.json();
        usageEl.textContent = `Today ${formatBytes(data.today_total_bytes)} | Session ${formatBytes(data.session_total_bytes)}`;
      } catch {
        // ignore transient usage errors
      }
    }

    function cacheKey(path) {
      return `${CACHE_PREFIX}${path}`;
    }

    function termCacheKey(terminalId) {
      return `${TERM_CACHE_PREFIX}${terminalId}`;
    }

    function trimTerminalCache(text) {
      if (!text || text.length <= TERM_CACHE_MAX_CHARS) return text || '';
      return text.slice(text.length - TERM_CACHE_MAX_CHARS);
    }

    function readTerminalCache(terminalId) {
      if (terminalCache.has(terminalId)) {
        return terminalCache.get(terminalId) || '';
      }
      try {
        const raw = localStorage.getItem(termCacheKey(terminalId)) || '';
        const trimmed = trimTerminalCache(raw);
        terminalCache.set(terminalId, trimmed);
        return trimmed;
      } catch {
        terminalCache.set(terminalId, '');
        return '';
      }
    }

    function writeTerminalCache(terminalId, text) {
      const trimmed = trimTerminalCache(text);
      terminalCache.set(terminalId, trimmed);
      try {
        localStorage.setItem(termCacheKey(terminalId), trimmed);
      } catch {
        // ignore local cache failures
      }
    }

    function appendTerminalCache(terminalId, chunk) {
      if (!chunk) return;
      writeTerminalCache(terminalId, `${readTerminalCache(terminalId)}${chunk}`);
    }

    function readFileCache(path, expectedSize) {
      try {
        const raw = localStorage.getItem(cacheKey(path));
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed.content !== 'string') return null;
        if (typeof expectedSize === 'number' && parsed.size_bytes !== expectedSize) return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function writeFileCache(file) {
      try {
        localStorage.setItem(cacheKey(file.path), JSON.stringify({
          path: file.path,
          content: file.content,
          truncated: file.truncated,
          hash: file.hash,
          size_bytes: file.size_bytes
        }));
      } catch {
        // ignore local cache failures
      }
    }

    function computePatch(baseText, nextText) {
      const a = Array.from(baseText);
      const b = Array.from(nextText);
      let start = 0;
      while (start < a.length && start < b.length && a[start] === b[start]) {
        start++;
      }

      let endA = a.length - 1;
      let endB = b.length - 1;
      while (endA >= start && endB >= start && a[endA] === b[endB]) {
        endA--;
        endB--;
      }

      return {
        start,
        delete_count: endA >= start ? (endA - start + 1) : 0,
        insert_text: endB >= start ? b.slice(start, endB + 1).join('') : ''
      };
    }

    function lineStartIndex(text, idx) {
      const pos = text.lastIndexOf('\n', Math.max(0, idx - 1));
      return pos === -1 ? 0 : pos + 1;
    }

    function lineEndIndex(text, idx) {
      const pos = text.indexOf('\n', idx);
      return pos === -1 ? text.length : pos;
    }

    async function hasActiveSession() {
      try {
        const res = await api('/auth/session', { method: 'GET' });
        return res.ok;
      } catch {
        return false;
      }
    }

    function showLogin(message) {
      app.style.display = 'none';
      login.style.display = 'flex';
      submitBtn.disabled = false;
      passwordInput.value = '';
      pinInput.value = '';
      if (message) {
        errorEl.textContent = message;
      }
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close();
      }
    }

    function initTerminal() {
      if (term) return;
      term = new Terminal({ cursorBlink: true, theme: { background: '#131313' } });
      fitAddon = new FitAddon.FitAddon();
      term.loadAddon(fitAddon);
      term.open(document.getElementById('terminal'));
      fitAddon.fit();

      term.onData((data) => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(new TextEncoder().encode(data));
        }
      });

      window.addEventListener('resize', () => {
        fitAddon.fit();
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'resize', cols: term.cols, rows: term.rows }));
        }
      });
    }

    function closeSocket() {
      if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
        ws.close();
      }
      ws = null;
    }

    function connectTerminal(terminalId, options = {}) {
      const switchingTerminal = terminalId !== activeTerminalId;
      activeTerminalId = terminalId;
      renderTerminalTabs();
      if (term && switchingTerminal) {
        term.clear();
      }
      if (term && switchingTerminal) {
        const cached = readTerminalCache(terminalId);
        if (cached) {
          term.write(cached);
        }
      }
      closeSocket();

      const hasCached = readTerminalCache(terminalId).length > 0;
      const shouldSkipScrollback = options.skipScrollback || hasCached;
      const wsUrl = `${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.host}/ws?terminal_id=${encodeURIComponent(terminalId)}&skip_scrollback=${shouldSkipScrollback ? '1' : '0'}`;
      const connectionId = ++wsConnectionId;
      ws = new WebSocket(wsUrl);
      const localWs = ws;
      ws.binaryType = 'arraybuffer';

      ws.onopen = () => {
        if (connectionId !== wsConnectionId) return;
        retries = 0;
        setStatus(`Connected: ${terminalId}`, '#4caf50');
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'resize', cols: term.cols, rows: term.rows }));
        }
      };

      ws.onmessage = (e) => {
        if (connectionId !== wsConnectionId) return;
        if (typeof e.data === 'string') {
          const msg = JSON.parse(e.data);
          if (msg.type === 'session_expired') {
            showLogin('Session expired. Please login again.');
          }
        } else {
          const bytes = new Uint8Array(e.data);
          const chunkText = textDecoder.decode(bytes);
          appendTerminalCache(terminalId, chunkText);
          term.write(bytes);
        }
      };

      ws.onclose = async () => {
        if (connectionId !== wsConnectionId) return;
        if (ws !== localWs) {
          return;
        }
        if (terminalId !== activeTerminalId) {
          return;
        }
        if (loggingOut) {
          const notice = logoutNotice || 'Logged out.';
          loggingOut = false;
          logoutNotice = '';
          showLogin(notice);
          return;
        }

        const activeSession = await hasActiveSession();
        if (!activeSession) {
          showLogin('Session expired. Please login again.');
          return;
        }

        if (retries < 4) {
          retries++;
          setStatus(`Reconnecting (${retries})...`, '#ff9800');
          setTimeout(() => connectTerminal(terminalId, { skipScrollback: true }), 600 * retries);
        } else {
          setStatus('Disconnected', '#ff9800');
        }
      };

      ws.onerror = () => {
        if (connectionId !== wsConnectionId) return;
        ws.close();
      };
    }

    async function authorize(password, pin) {
      return api('/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password, pin })
      });
    }

    async function logout(revokeAll) {
      await api('/auth/logout', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ revoke_all: revokeAll })
      });
    }

    async function loadTerminals() {
      const res = await api('/api/terminals');
      if (!res.ok) throw new Error('failed terminals');
      terminals = await res.json();
      if (terminals.length === 0) {
        await createTerminal('.');
      }
      renderTerminalTabs();
      if (!activeTerminalId || !terminals.some((t) => t.id === activeTerminalId)) {
        connectTerminal(terminals[0].id);
      }
    }

    async function createTerminal(cwd) {
      const res = await api('/api/terminals', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ cwd: cwd || '.' })
      });
      if (!res.ok) {
        const msg = await res.text();
        alert(msg || 'Cannot create terminal');
        return null;
      }
      const item = await res.json();
      terminals.push(item);
      renderTerminalTabs();
      connectTerminal(item.id);
      selectedDir = cwd || '.';
      return item;
    }

    async function deleteTerminal(id) {
      const res = await api(`/api/terminals/${encodeURIComponent(id)}`, { method: 'DELETE' });
      if (res.status !== 204) {
        alert('Cannot close terminal');
        return;
      }
      try {
        localStorage.removeItem(termCacheKey(id));
      } catch {
        // ignore local cache failures
      }
      terminalCache.delete(id);
      terminals = terminals.filter((t) => t.id !== id);
      if (activeTerminalId === id) {
        if (terminals.length === 0) {
          await createTerminal(selectedDir || '.');
        } else {
          connectTerminal(terminals[0].id);
        }
      }
      renderTerminalTabs();
    }

    function renderTerminalTabs() {
      termTabs.querySelectorAll('.tab').forEach((node) => node.remove());
      terminals.forEach((item) => {
        const tab = document.createElement('div');
        tab.className = `tab ${item.id === activeTerminalId ? 'active' : ''}`;
        tab.innerHTML = `<span>${item.title}</span>`;
        tab.onclick = () => connectTerminal(item.id);

        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'x';
        closeBtn.onclick = (e) => {
          e.stopPropagation();
          deleteTerminal(item.id);
        };
        tab.appendChild(closeBtn);
        termTabs.appendChild(tab);
      });
    }

    async function fetchTree(path) {
      const res = await api(`/api/fs/tree?path=${encodeURIComponent(path)}`);
      if (!res.ok) return null;
      return res.json();
    }

    async function fetchFile(path) {
      const res = await api(`/api/fs/file?path=${encodeURIComponent(path)}`);
      if (!res.ok) return null;
      return res.json();
    }

    function parentPath(path) {
      if (!path || path === '.') return '.';
      const idx = path.lastIndexOf('/');
      if (idx <= 0) return '.';
      return path.slice(0, idx);
    }

    function renderPreviewTabs() {
      previewTabsEl.innerHTML = '';
      if (openFiles.length === 0) {
        activeFilePath = null;
        previewEl.textContent = 'Select a file to preview';
        return;
      }
      openFiles.forEach((file) => {
        const tab = document.createElement('div');
        tab.className = `preview-tab ${file.path === activeFilePath ? 'active' : ''}`;

        const label = document.createElement('button');
        label.className = 'label';
        label.textContent = file.path.split('/').pop();
        label.onclick = () => {
          activeFilePath = file.path;
          editingPath = null;
          editingBaseHash = null;
          editingOriginal = '';
          editorEl.style.display = 'none';
          previewEl.style.display = 'block';
          previewEl.textContent = file.content + (file.truncated ? '\n\n[truncated]' : '');
          renderPreviewTabs();
        };
        tab.appendChild(label);

        const closeBtn = document.createElement('button');
        closeBtn.className = 'close';
        closeBtn.textContent = 'x';
        closeBtn.onclick = (e) => {
          e.stopPropagation();
          const idx = openFiles.findIndex((item) => item.path === file.path);
          if (idx >= 0) {
            openFiles.splice(idx, 1);
          }
          if (activeFilePath === file.path) {
            const fallback = openFiles[idx] || openFiles[idx - 1];
            if (fallback) {
              activeFilePath = fallback.path;
              previewEl.textContent = fallback.content + (fallback.truncated ? '\n\n[truncated]' : '');
            } else {
              activeFilePath = null;
              previewEl.textContent = 'Select a file to preview';
            }
          }
          renderPreviewTabs();
        };
        tab.appendChild(closeBtn);
        previewTabsEl.appendChild(tab);
      });
    }

    async function openFile(path) {
      const meta = fileMeta.get(path);
      if (meta && typeof meta.size_bytes === 'number') {
        if (meta.size_bytes > FILE_EDIT_LIMIT_BYTES) {
          alert('File is too large to open in web preview/editor.');
          return;
        }
        if (meta.size_bytes > FILE_WARN_BYTES) {
          const proceed = window.confirm(`This file is ${formatBytes(meta.size_bytes)} and may use more data. Open anyway?`);
          if (!proceed) return;
        }
      }

      const cached = readFileCache(path, meta ? meta.size_bytes : undefined);
      if (cached) {
        const existingCached = openFiles.find((item) => item.path === cached.path);
        if (!existingCached) {
          openFiles.push(cached);
        } else {
          existingCached.content = cached.content;
          existingCached.truncated = cached.truncated;
          existingCached.hash = cached.hash;
          existingCached.size_bytes = cached.size_bytes;
        }
        activeFilePath = cached.path;
        editingPath = null;
        editingBaseHash = null;
        editingOriginal = '';
        editorEl.style.display = 'none';
        previewEl.style.display = 'block';
        previewEl.textContent = cached.content + (cached.truncated ? '\n\n[truncated]' : '');
        renderPreviewTabs();
        selectedDir = parentPath(cached.path);
        return;
      }

      const file = await fetchFile(path);
      if (!file) return;
      const existing = openFiles.find((item) => item.path === file.path);
      if (!existing) {
        openFiles.push(file);
      } else {
        existing.content = file.content;
        existing.truncated = file.truncated;
        existing.hash = file.hash;
        existing.size_bytes = file.size_bytes;
      }
      writeFileCache(file);
      activeFilePath = file.path;
      editingPath = null;
      editingBaseHash = null;
      editingOriginal = '';
      editorEl.style.display = 'none';
      previewEl.style.display = 'block';
      previewEl.textContent = file.content + (file.truncated ? '\n\n[truncated]' : '');
      renderPreviewTabs();
      selectedDir = parentPath(file.path);
    }

    async function saveActiveFile() {
      if (!editingPath) return;
      const content = editorEl.value;
      const patch = computePatch(editingOriginal, content);
      const res = await api('/api/fs/file/diff', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          path: editingPath,
          base_hash: editingBaseHash,
          start: patch.start,
          delete_count: patch.delete_count,
          insert_text: patch.insert_text
        })
      });
      if (!res.ok) {
        const msg = await res.text();
        alert(msg || 'Cannot save file');
        return;
      }
      const saved = await res.json();
      const existing = openFiles.find((item) => item.path === editingPath);
      if (existing) {
        existing.content = content;
        existing.truncated = false;
        existing.hash = saved.hash;
        existing.size_bytes = saved.size_bytes;
        writeFileCache(existing);
      }
      previewEl.textContent = content;
      editingPath = null;
      editingBaseHash = null;
      editingOriginal = '';
      editorEl.style.display = 'none';
      previewEl.style.display = 'block';
      await renderTree();
      await refreshUsage();
    }

    async function renderTree() {
      treeEl.innerHTML = '';
      fileMeta.clear();
      const root = await fetchTree('.');
      if (!root) {
        treeEl.textContent = 'Failed to load file tree';
        return;
      }

      const renderNodes = async (container, path, ancestry) => {
        const tree = await fetchTree(path);
        if (!tree) return;
        for (let i = 0; i < tree.entries.length; i++) {
          const entry = tree.entries[i];
          fileMeta.set(entry.path, entry);
          const isLast = i === tree.entries.length - 1;
          const row = document.createElement('div');
          row.className = 'tree-item';
          if (entry.path === selectedDir) {
            row.classList.add('active');
          }
          const expanded = expandedDirs.has(entry.path);
          const icon = entry.is_dir ? (expanded ? 'ðŸ“‚' : 'ðŸ“') : 'ðŸ“„';
          const toggle = entry.is_dir ? (expanded ? 'â–¾' : 'â–¸') : ' ';
          const guides = ancestry.map((hasNext) => (hasNext ? 'â”‚  ' : '   ')).join('');
          const branch = isLast ? 'â””â”€ ' : 'â”œâ”€ ';
          row.textContent = `${guides}${branch}${toggle} ${icon} ${entry.name}`;
          container.appendChild(row);

          if (entry.is_dir) {
            row.onclick = async () => {
              selectedDir = entry.path;
              if (expandedDirs.has(entry.path)) {
                expandedDirs.delete(entry.path);
              } else {
                expandedDirs.add(entry.path);
              }
              await renderTree();
            };
            if (expanded) {
              const next = document.createElement('div');
              next.className = 'indent';
              row.after(next);
              await renderNodes(next, entry.path, [...ancestry, !isLast]);
            }
          } else {
            row.onclick = () => openFile(entry.path);
          }
        }
      };

      await renderNodes(treeEl, '.', []);
    }

    async function bootstrapWorkspace() {
      initTerminal();
      login.style.display = 'none';
      app.style.display = 'flex';
      await Promise.all([loadTerminals(), renderTree()]);
      await refreshUsage();
      if (usageTimer) {
        clearInterval(usageTimer);
      }
      usageTimer = setInterval(refreshUsage, 20000);
      if (fitAddon) fitAddon.fit();
    }

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const password = passwordInput.value;
      const pin = pinInput.value.trim() || null;
      errorEl.textContent = '';
      submitBtn.disabled = true;

      try {
        const res = await authorize(password, pin);
        if (!res.ok) {
          if (res.status === 423) {
            errorEl.textContent = 'Access locked. Restart CodeWebway to login again.';
          } else if (res.status === 429) {
            errorEl.textContent = 'Too many attempts. Try again later.';
          } else {
            errorEl.textContent = 'Invalid password or PIN';
          }
          submitBtn.disabled = false;
          return;
        }
      } catch {
        errorEl.textContent = 'Cannot reach server';
        submitBtn.disabled = false;
        return;
      }

      submitBtn.disabled = false;
      await bootstrapWorkspace();
    });

    newTabBtn.addEventListener('click', () => createTerminal(selectedDir || '.'));

    openShellHereBtn.addEventListener('click', () => createTerminal(selectedDir || '.'));
    refreshTreeBtn.addEventListener('click', () => renderTree());

    editFileBtn.addEventListener('click', () => {
      if (!activeFilePath) return;
      const current = openFiles.find((item) => item.path === activeFilePath);
      if (!current) return;
      if (current.truncated) {
        alert('File is truncated in preview. Open a smaller file to edit.');
        return;
      }
      if ((current.size_bytes || current.content.length) > FILE_EDIT_LIMIT_BYTES) {
        alert('File is too large to edit in-browser.');
        return;
      }
      editingPath = current.path;
      editingBaseHash = current.hash;
      editingOriginal = current.content;
      editorEl.value = current.content;
      previewEl.style.display = 'none';
      editorEl.style.display = 'block';
      editorEl.focus();
    });

    saveFileBtn.addEventListener('click', () => {
      saveActiveFile();
    });

    cancelEditBtn.addEventListener('click', () => {
      editingPath = null;
      editingBaseHash = null;
      editingOriginal = '';
      editorEl.style.display = 'none';
      previewEl.style.display = 'block';
    });

    editorEl.addEventListener('keydown', (e) => {
      if (e.key === 'Tab') {
        e.preventDefault();
        const text = editorEl.value;
        const start = editorEl.selectionStart;
        const end = editorEl.selectionEnd;
        const hasSelection = end > start;

        if (!e.shiftKey) {
          if (!hasSelection) {
            editorEl.value = `${text.slice(0, start)}  ${text.slice(end)}`;
            editorEl.selectionStart = editorEl.selectionEnd = start + 2;
            return;
          }

          const startLine = lineStartIndex(text, start);
          const endLine = lineEndIndex(text, end);
          const block = text.slice(startLine, endLine);
          const indented = block
            .split('\n')
            .map((line) => `  ${line}`)
            .join('\n');
          editorEl.value = `${text.slice(0, startLine)}${indented}${text.slice(endLine)}`;
          editorEl.selectionStart = start + 2;
          editorEl.selectionEnd = end + (2 * block.split('\n').length);
          return;
        }

        const startLine = lineStartIndex(text, start);
        const endLine = lineEndIndex(text, end);
        const lines = text.slice(startLine, endLine).split('\n');
        let removed = 0;
        const outdented = lines.map((line) => {
          if (line.startsWith('  ')) {
            removed += 2;
            return line.slice(2);
          }
          if (line.startsWith('\t')) {
            removed += 1;
            return line.slice(1);
          }
          return line;
        }).join('\n');
        editorEl.value = `${text.slice(0, startLine)}${outdented}${text.slice(endLine)}`;

        if (!hasSelection) {
          const caretShift = lines[0].startsWith('  ') ? 2 : (lines[0].startsWith('\t') ? 1 : 0);
          const next = Math.max(start - caretShift, startLine);
          editorEl.selectionStart = editorEl.selectionEnd = next;
        } else {
          const firstShift = lines[0].startsWith('  ') ? 2 : (lines[0].startsWith('\t') ? 1 : 0);
          editorEl.selectionStart = Math.max(start - firstShift, startLine);
          editorEl.selectionEnd = Math.max(editorEl.selectionStart, end - removed);
        }
        return;
      }

      if (e.key === 'Enter') {
        e.preventDefault();
        const text = editorEl.value;
        const start = editorEl.selectionStart;
        const end = editorEl.selectionEnd;
        const currentLineStart = lineStartIndex(text, start);
        const beforeCaret = text.slice(currentLineStart, start);
        const indent = (beforeCaret.match(/^[\t ]*/) || [''])[0];
        const insert = `\n${indent}`;
        editorEl.value = `${text.slice(0, start)}${insert}${text.slice(end)}`;
        const nextPos = start + insert.length;
        editorEl.selectionStart = editorEl.selectionEnd = nextPos;
      }
    });

    logoutBtn.addEventListener('click', async () => {
      const confirmLogout = window.confirm('Log out now?');
      if (!confirmLogout) return;

      const lockSystem = window.confirm(
        'Close system now?\nOK = lock access until server restart\nCancel = logout only (you can login again elsewhere)'
      );
      loggingOut = true;
      logoutNotice = lockSystem
        ? 'Logged out and locked access. Restart CodeWebway to login again.'
        : 'Logged out.';

      await logout(lockSystem);
      closeSocket();
      terminals.forEach((t) => {
        try {
          localStorage.removeItem(termCacheKey(t.id));
        } catch {
          // ignore local cache failures
        }
      });
      terminalCache.clear();
      showLogin(logoutNotice);
      loggingOut = false;
      logoutNotice = '';
      if (usageTimer) {
        clearInterval(usageTimer);
        usageTimer = null;
      }
    });
  </script>
</body>
</html>

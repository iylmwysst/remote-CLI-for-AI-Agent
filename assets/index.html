<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CodeWebway</title>
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #131313; color: #ddd; font-family: ui-sans-serif, -apple-system, Segoe UI, sans-serif; height: 100vh; }
    #login {
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      background: radial-gradient(circle at top, #2a2a2a, #111 70%);
    }
    .card {
      width: 100%;
      max-width: 460px;
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid #3f3f3f;
      border-radius: 12px;
      padding: 22px;
    }
    .card h1 { font-size: 20px; margin-bottom: 8px; }
    .card p { color: #aaa; margin-bottom: 14px; font-size: 14px; }
    .stack { display: flex; flex-direction: column; gap: 10px; }
    .row { display: flex; gap: 8px; }
    input, select {
      width: 100%;
      background: #111;
      border: 1px solid #444;
      color: #eee;
      border-radius: 8px;
      padding: 10px 12px;
      font-size: 14px;
      outline: none;
    }
    button {
      border: 1px solid #4f4f4f;
      border-radius: 8px;
      background: #2f65ff;
      color: #fff;
      padding: 10px 12px;
      font-size: 13px;
      cursor: pointer;
    }
    button:disabled { opacity: 0.6; cursor: wait; }
    .ghost { background: #2d2d2d; }
    #error { color: #ff8a80; margin-top: 10px; min-height: 20px; font-size: 13px; }
    #login-note {
      color: #f4c36a;
      margin-top: 8px;
      min-height: 18px;
      font-size: 12px;
    }

    #app { display: none; height: 100vh; flex-direction: column; }
    #session-warning {
      display: none;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      background: #3a2c12;
      border-bottom: 1px solid #5b4420;
      color: #ffd98e;
      padding: 6px 10px;
      font-size: 12px;
    }
    #session-warning button {
      padding: 4px 8px;
      font-size: 12px;
      border-radius: 6px;
    }
    #topbar {
      border-bottom: 1px solid #2f2f2f;
      background: #1b1b1b;
      color: #c8c8c8;
      font-family: monospace;
      font-size: 12px;
      padding: 6px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    #topbar-right {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #usage {
      color: #9ad1ff;
      font-size: 11px;
    }
    #workspace { flex: 1; display: flex; min-height: 0; }
    #files {
      width: 34%;
      min-width: 260px;
      border-right: 1px solid #2f2f2f;
      display: flex;
      flex-direction: column;
      min-height: 0;
      background: #171717;
    }
    #file-head {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      padding: 8px;
      border-bottom: 1px solid #2f2f2f;
    }
    #tree { flex: 1; overflow: auto; padding: 8px; border-bottom: 1px solid #2f2f2f; }
    #preview-tabs {
      display: flex;
      gap: 6px;
      overflow-x: auto;
      padding: 8px;
      border-bottom: 1px solid #2f2f2f;
    }
    #preview {
      flex: 1;
      overflow: auto;
      padding: 10px;
      font-family: ui-monospace, Menlo, monospace;
      white-space: pre;
      font-size: 12px;
      color: #ddd;
    }
    #editor-actions {
      display: flex;
      gap: 8px;
      padding: 8px;
      border-bottom: 1px solid #2f2f2f;
      background: #151515;
    }
    #editor-actions button {
      background: #2d2d2d;
      border-color: #4f4f4f;
      color: #ddd;
    }
    #editor-actions button.primary {
      background: #2f65ff;
      border-color: #2f65ff;
      color: #fff;
    }
    #editor-actions button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    #editor {
      display: none;
      flex: 1;
      min-height: 140px;
      width: 100%;
      resize: vertical;
      background: #111;
      color: #e5e5e5;
      border: 0;
      border-top: 1px solid #2f2f2f;
      padding: 10px;
      font-family: ui-monospace, Menlo, monospace;
      font-size: 12px;
      line-height: 1.4;
      outline: none;
    }
    .tree-item {
      padding: 4px 6px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-family: ui-monospace, Menlo, monospace;
      white-space: pre;
    }
    .tree-item:hover { background: #222; }
    .tree-item.active { background: #2b2b2b; }
    .indent { margin-left: 8px; }

    #terms { flex: 1; display: flex; flex-direction: column; min-height: 0; }

    body.terminal-only #files { display: none; }
    body.terminal-only #terms  { flex: 1; }
    #term-tabs {
      display: flex;
      gap: 8px;
      align-items: center;
      overflow-x: auto;
      border-bottom: 1px solid #2f2f2f;
      padding: 8px;
      background: #161616;
    }
    .tab {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 7px;
      border: 1px solid #383838;
      background: #232323;
      cursor: pointer;
      font-size: 12px;
      white-space: nowrap;
    }
    .tab.active { border-color: #2f65ff; }
    .tab button {
      padding: 2px 6px;
      background: #3a3a3a;
      border-color: #575757;
      font-size: 11px;
    }
    .tab .title {
      max-width: 160px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .tab .icon-btn {
      padding: 2px 6px;
      min-width: 24px;
      text-align: center;
    }
    .preview-tab {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      border-radius: 7px;
      border: 1px solid #383838;
      background: #232323;
      font-size: 12px;
      white-space: nowrap;
    }
    .preview-tab.active { border-color: #2f65ff; }
    .preview-tab .label {
      background: transparent;
      border: 0;
      color: #ddd;
      padding: 0;
      font-size: 12px;
    }
    .preview-tab .close {
      padding: 2px 6px;
      font-size: 11px;
      background: #3a3a3a;
      border: 1px solid #575757;
      border-radius: 6px;
      color: #fff;
    }
    #terminal { flex: 1; min-height: 0; padding: 6px; }
    #logout-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.6);
      z-index: 50;
    }
    #logout-modal.open { display: flex; }
    .modal-card {
      width: 100%;
      max-width: 420px;
      background: #161616;
      border: 1px solid #3b3b3b;
      border-radius: 12px;
      padding: 14px;
    }
    .modal-card h3 {
      font-size: 15px;
      margin-bottom: 8px;
    }
    .modal-card p {
      color: #a9a9a9;
      font-size: 13px;
      margin-bottom: 12px;
    }
    .modal-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }
    #share-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.6);
      z-index: 60;
    }
    #share-modal.open { display: flex; }
    #share-form {
      display: grid;
      gap: 10px;
      margin-bottom: 10px;
    }
    #share-form .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    #share-link-output {
      font-family: ui-monospace, Menlo, monospace;
      font-size: 12px;
      color: #9ad1ff;
      min-height: 18px;
      margin-bottom: 8px;
      word-break: break-all;
    }
    #temp-links-list {
      max-height: 260px;
      overflow: auto;
      border: 1px solid #343434;
      border-radius: 8px;
      padding: 6px;
      display: grid;
      gap: 6px;
    }
    .temp-link-item {
      border: 1px solid #3b3b3b;
      border-radius: 8px;
      padding: 8px;
      display: grid;
      gap: 6px;
      font-size: 12px;
      color: #c9c9c9;
    }
    .temp-link-item .meta {
      color: #9f9f9f;
      font-size: 11px;
    }
    .temp-link-item .actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
  </style>
</head>
<body>
  <div id="login">
    <form class="card" id="login-form">
      <h1>CodeWebway</h1>
      <p>Enter Token and PIN to open workspace</p>
      <div class="stack">
        <input id="password" type="password" autocomplete="current-password" placeholder="Token" required />
        <div class="row">
          <input id="pin" type="password" autocomplete="one-time-code" placeholder="PIN" />
          <button id="submit" type="submit">Connect</button>
        </div>
      </div>
      <div id="error"></div>
      <div id="login-note"></div>
    </form>
  </div>

  <div id="app">
    <div id="session-warning">
      <span id="session-warning-text"></span>
      <button id="stay-signed-in" type="button">Stay signed in</button>
    </div>
    <div id="topbar">
      <div id="status">Connected</div>
      <div id="topbar-right">
        <span id="usage">Today 0 B | Session 0 B</span>
        <button id="logout" class="ghost" type="button">Logout</button>
      </div>
    </div>
    <div id="workspace">
      <section id="files">
        <div id="file-head">
          <strong>Files</strong>
          <div class="row">
            <button id="refresh-tree" class="ghost" type="button">Refresh</button>
            <button id="open-shell-here" class="ghost" type="button">Open Shell Here</button>
          </div>
        </div>
        <div id="tree"></div>
        <div id="preview-tabs"></div>
        <div id="editor-actions">
          <button id="edit-file" class="ghost" type="button">Edit</button>
          <button id="save-file" type="button">Save</button>
          <button id="cancel-edit" class="ghost" type="button">Cancel</button>
        </div>
        <pre id="preview">Select a file to preview</pre>
        <textarea id="editor" spellcheck="false"></textarea>
      </section>
      <section id="terms">
        <div id="term-tabs">
          <button id="new-tab" type="button">+ New Tab</button>
        </div>
        <div id="terminal"></div>
      </section>
    </div>
  </div>

  <div id="logout-modal" role="dialog" aria-modal="true" aria-labelledby="logout-title">
    <div class="modal-card">
      <h3 id="logout-title">Logout options</h3>
      <p>Choose whether to logout only, or lockout and shutdown the server now.</p>
      <div class="modal-actions">
        <button id="logout-cancel" class="ghost" type="button">Cancel</button>
        <button id="logout-only" class="ghost" type="button">Logout only</button>
        <button id="logout-lock" type="button">Lockout + Shutdown</button>
      </div>
    </div>
  </div>

  <div id="share-modal" role="dialog" aria-modal="true" aria-labelledby="share-title">
    <div class="modal-card">
      <h3 id="share-title">Temporary Link</h3>
      <p>Create short-lived link without sharing your main Token/PIN.</p>
      <div id="share-form">
        <div class="row">
          <select id="temp-ttl">
            <option value="5">5 min</option>
            <option value="15" selected>15 min</option>
            <option value="60">1 hour</option>
          </select>
          <select id="temp-scope">
            <option value="read-only" selected>Read only</option>
            <option value="interactive">Interactive</option>
          </select>
        </div>
        <div class="row">
          <label><input id="temp-one-time" type="checkbox" checked> One-time</label>
          <input id="temp-max-uses" type="number" min="1" max="100" value="5" />
        </div>
        <div class="row">
          <label><input id="temp-bind-terminal" type="checkbox"> Bind active tab</label>
          <button id="create-temp-link" type="button">Create Temporary Link</button>
        </div>
      </div>
      <div id="share-link-output"></div>
      <div id="temp-links-list"></div>
      <div class="modal-actions">
        <button id="share-close" class="ghost" type="button">Close</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
  <script>
    const app = document.getElementById('app');
    const login = document.getElementById('login');
    const form = document.getElementById('login-form');
    const passwordInput = document.getElementById('password');
    const pinInput = document.getElementById('pin');
    const submitBtn = document.getElementById('submit');
    const errorEl = document.getElementById('error');
    const loginNoteEl = document.getElementById('login-note');
    const statusEl = document.getElementById('status');
    const usageEl = document.getElementById('usage');
    const shareBtn = document.getElementById('share');
    const sessionWarningEl = document.getElementById('session-warning');
    const sessionWarningTextEl = document.getElementById('session-warning-text');
    const staySignedInBtn = document.getElementById('stay-signed-in');
    const logoutBtn = document.getElementById('logout');
    const newTabBtn = document.getElementById('new-tab');
    const termTabs = document.getElementById('term-tabs');
    const treeEl = document.getElementById('tree');
    const previewTabsEl = document.getElementById('preview-tabs');
    const previewEl = document.getElementById('preview');
    const editorEl = document.getElementById('editor');
    const editFileBtn = document.getElementById('edit-file');
    const saveFileBtn = document.getElementById('save-file');
    const cancelEditBtn = document.getElementById('cancel-edit');
    const openShellHereBtn = document.getElementById('open-shell-here');
    const refreshTreeBtn = document.getElementById('refresh-tree');
    const logoutModal = document.getElementById('logout-modal');
    const logoutOnlyBtn = document.getElementById('logout-only');
    const logoutLockBtn = document.getElementById('logout-lock');
    const logoutCancelBtn = document.getElementById('logout-cancel');
    const shareModal = document.getElementById('share-modal');
    const shareCloseBtn = document.getElementById('share-close');
    const tempTtlEl = document.getElementById('temp-ttl');
    const tempScopeEl = document.getElementById('temp-scope');
    const tempOneTimeEl = document.getElementById('temp-one-time');
    const tempMaxUsesEl = document.getElementById('temp-max-uses');
    const tempBindTerminalEl = document.getElementById('temp-bind-terminal');
    const createTempLinkBtn = document.getElementById('create-temp-link');
    const shareLinkOutputEl = document.getElementById('share-link-output');
    const tempLinksListEl = document.getElementById('temp-links-list');

    let ws;
    let retries = 0;
    let wsConnectionId = 0;
    let term;
    let fitAddon;
    let loggingOut = false;
    let logoutNotice = '';

    let terminals = [];
    let activeTerminalId = null;
    let selectedDir = '.';
    const expandedDirs = new Set(['.']);

    const openFiles = [];
    let activeFilePath = null;
    let editingPath = null;
    let editingBaseHash = null;
    let editingOriginal = '';
    let usageTimer = null;
    let sessionTimer = null;
    let publicTimer = null;
    let tempLinksRefreshTimer = null;
    const fileMeta = new Map();
    const FILE_WARN_BYTES = 128 * 1024;
    const FILE_EDIT_LIMIT_BYTES = 512 * 1024;
    const CACHE_PREFIX = 'rwtty:file:';
    const TERM_CACHE_PREFIX = 'cw:term:';
    const TERM_CACHE_MAX_CHARS = 500000;
    const terminalCache = new Map();
    const textDecoder = new TextDecoder();
    let sessionAccess = {
      readOnly: false,
      boundTerminalId: null,
      tempLinkId: null
    };
    let tempLinks = [];

    function formatSeconds(total) {
      const safe = Math.max(0, Math.floor(total || 0));
      const h = Math.floor(safe / 3600).toString().padStart(2, '0');
      const m = Math.floor((safe % 3600) / 60).toString().padStart(2, '0');
      const s = Math.floor(safe % 60).toString().padStart(2, '0');
      return `${h}:${m}:${s}`;
    }

    function setStatus(text, color) {
      statusEl.textContent = text;
      statusEl.style.color = color || '#c8c8c8';
    }

    function updateEditorActionState() {
      const current = activeFilePath
        ? openFiles.find((item) => item.path === activeFilePath)
        : null;
      const canEdit = Boolean(
        current &&
        !current.truncated &&
        (current.size_bytes || current.content.length) <= FILE_EDIT_LIMIT_BYTES
      );
      const editing = Boolean(editingPath);
      const readOnly = sessionAccess.readOnly === true;

      editFileBtn.disabled = editing || !canEdit || readOnly;
      saveFileBtn.disabled = !editing || readOnly;
      cancelEditBtn.disabled = !editing;
      saveFileBtn.classList.toggle('primary', editing);
    }

    function applySessionAccessState() {
      const readOnly = sessionAccess.readOnly === true;
      const bound = sessionAccess.boundTerminalId;
      const disableTerminalOps = readOnly || Boolean(bound);

      newTabBtn.disabled = disableTerminalOps;
      openShellHereBtn.disabled = disableTerminalOps;
      if (shareBtn) {
        shareBtn.disabled = readOnly || Boolean(sessionAccess.tempLinkId);
      }

      if (bound && activeTerminalId && activeTerminalId !== bound) {
        connectTerminal(bound, { skipScrollback: false });
      }
      updateEditorActionState();
    }

    function chooseLogoutMode() {
      return new Promise((resolve) => {
        const close = (value) => {
          logoutModal.classList.remove('open');
          logoutOnlyBtn.onclick = null;
          logoutLockBtn.onclick = null;
          logoutCancelBtn.onclick = null;
          logoutModal.onclick = null;
          resolve(value);
        };

        logoutOnlyBtn.onclick = () => close(false);
        logoutLockBtn.onclick = () => close(true);
        logoutCancelBtn.onclick = () => close(null);
        logoutModal.onclick = (e) => {
          if (e.target === logoutModal) close(null);
        };
        logoutModal.classList.add('open');
      });
    }

    async function api(path, options = {}) {
      const res = await fetch(path, options);
      return res;
    }

    function formatBytes(bytes) {
      if (bytes < 1024) return `${bytes} B`;
      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
      return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    }

    async function refreshUsage() {
      try {
        const res = await api('/api/usage');
        if (!res.ok) return;
        const data = await res.json();
        usageEl.textContent = `Today ${formatBytes(data.today_total_bytes)} | Session ${formatBytes(data.session_total_bytes)}`;
      } catch {
        // ignore transient usage errors
      }
    }

    function cacheKey(path) {
      return `${CACHE_PREFIX}${path}`;
    }

    function termCacheKey(terminalId) {
      return `${TERM_CACHE_PREFIX}${terminalId}`;
    }

    function trimTerminalCache(text) {
      if (!text || text.length <= TERM_CACHE_MAX_CHARS) return text || '';
      return text.slice(text.length - TERM_CACHE_MAX_CHARS);
    }

    function readTerminalCache(terminalId) {
      if (terminalCache.has(terminalId)) {
        return terminalCache.get(terminalId) || '';
      }
      try {
        const raw = localStorage.getItem(termCacheKey(terminalId)) || '';
        const trimmed = trimTerminalCache(raw);
        terminalCache.set(terminalId, trimmed);
        return trimmed;
      } catch {
        terminalCache.set(terminalId, '');
        return '';
      }
    }

    function writeTerminalCache(terminalId, text) {
      const trimmed = trimTerminalCache(text);
      terminalCache.set(terminalId, trimmed);
      try {
        localStorage.setItem(termCacheKey(terminalId), trimmed);
      } catch {
        // ignore local cache failures
      }
    }

    function appendTerminalCache(terminalId, chunk) {
      if (!chunk) return;
      writeTerminalCache(terminalId, `${readTerminalCache(terminalId)}${chunk}`);
    }

    function readFileCache(path, expectedSize) {
      try {
        const raw = localStorage.getItem(cacheKey(path));
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed.content !== 'string') return null;
        if (typeof expectedSize === 'number' && parsed.size_bytes !== expectedSize) return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function writeFileCache(file) {
      try {
        localStorage.setItem(cacheKey(file.path), JSON.stringify({
          path: file.path,
          content: file.content,
          truncated: file.truncated,
          hash: file.hash,
          size_bytes: file.size_bytes
        }));
      } catch {
        // ignore local cache failures
      }
    }

    function computePatch(baseText, nextText) {
      const a = Array.from(baseText);
      const b = Array.from(nextText);
      let start = 0;
      while (start < a.length && start < b.length && a[start] === b[start]) {
        start++;
      }

      let endA = a.length - 1;
      let endB = b.length - 1;
      while (endA >= start && endB >= start && a[endA] === b[endB]) {
        endA--;
        endB--;
      }

      return {
        start,
        delete_count: endA >= start ? (endA - start + 1) : 0,
        insert_text: endB >= start ? b.slice(start, endB + 1).join('') : ''
      };
    }

    function lineStartIndex(text, idx) {
      const pos = text.lastIndexOf('\n', Math.max(0, idx - 1));
      return pos === -1 ? 0 : pos + 1;
    }

    function lineEndIndex(text, idx) {
      const pos = text.indexOf('\n', idx);
      return pos === -1 ? text.length : pos;
    }

    async function hasActiveSession() {
      try {
        const res = await api('/auth/session', { method: 'GET' });
        return res.ok;
      } catch {
        return false;
      }
    }

    async function fetchPublicStatus() {
      try {
        const res = await api('/auth/public-status');
        if (!res.ok) return null;
        return res.json();
      } catch {
        return null;
      }
    }

    async function refreshLoginNote() {
      const status = await fetchPublicStatus();
      if (!status) return;
      if (status.auto_shutdown_disabled === true) {
        loginNoteEl.textContent = 'No login activity: auto-shutdown disabled (public no-expiry; lockout + shutdown only).';
        return;
      }
      loginNoteEl.textContent = `No login activity: auto-shutdown in ${formatSeconds(status.shutdown_remaining_secs)}.`;
    }

    function setLoginPolling(enabled) {
      if (publicTimer) {
        clearInterval(publicTimer);
        publicTimer = null;
      }
      if (enabled) {
        refreshLoginNote();
        publicTimer = setInterval(refreshLoginNote, 15000);
      } else {
        loginNoteEl.textContent = '';
      }
    }

    async function fetchSessionStatus() {
      try {
        const res = await api('/auth/session/status');
        if (!res.ok) return null;
        return res.json();
      } catch {
        return null;
      }
    }

    async function extendSession(pin) {
      return api('/auth/extend', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pin })
      });
    }

    function hideSessionWarning() {
      sessionWarningEl.style.display = 'none';
      sessionWarningTextEl.textContent = '';
    }

    async function refreshSessionWarning() {
      const status = await fetchSessionStatus();
      if (!status) {
        hideSessionWarning();
        return;
      }
      sessionAccess.readOnly = status.read_only === true;
      sessionAccess.boundTerminalId = status.bound_terminal_id || null;
      sessionAccess.tempLinkId = status.temp_link_id || null;
      applySessionAccessState();
      const remaining = Math.min(status.remaining_idle_secs, status.remaining_absolute_secs);
      if (remaining <= status.warning_window_secs) {
        sessionWarningTextEl.textContent = `Session will expire in ${formatSeconds(remaining)}.`;
        sessionWarningEl.style.display = 'flex';
      } else {
        hideSessionWarning();
      }
    }

    function setSessionPolling(enabled) {
      if (sessionTimer) {
        clearInterval(sessionTimer);
        sessionTimer = null;
      }
      if (enabled) {
        refreshSessionWarning();
        sessionTimer = setInterval(refreshSessionWarning, 10000);
      } else {
        hideSessionWarning();
      }
    }

    function showLogin(message) {
      app.style.display = 'none';
      login.style.display = 'flex';
      submitBtn.disabled = false;
      passwordInput.value = '';
      pinInput.value = '';
      if (message) {
        errorEl.textContent = message;
      }
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close();
      }
      setTempLinksModal(false);
      tempLinks = [];
      shareLinkOutputEl.textContent = '';
      sessionAccess = { readOnly: false, boundTerminalId: null, tempLinkId: null };
      setSessionPolling(false);
      setLoginPolling(true);
      updateEditorActionState();
    }

    function initTerminal() {
      if (term) return;
      term = new Terminal({ cursorBlink: true, theme: { background: '#131313' } });
      fitAddon = new FitAddon.FitAddon();
      term.loadAddon(fitAddon);
      term.open(document.getElementById('terminal'));
      fitAddon.fit();

      term.onData((data) => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(new TextEncoder().encode(data));
        }
      });

      window.addEventListener('resize', () => {
        fitAddon.fit();
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'resize', cols: term.cols, rows: term.rows }));
        }
      });
    }

    function closeSocket() {
      if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
        ws.close();
      }
      ws = null;
    }

    function connectTerminal(terminalId, options = {}) {
      if (sessionAccess.boundTerminalId && terminalId !== sessionAccess.boundTerminalId) {
        alert('This session is bound to another terminal tab.');
        return;
      }
      const switchingTerminal = terminalId !== activeTerminalId;
      activeTerminalId = terminalId;
      renderTerminalTabs();
      if (term && switchingTerminal) {
        term.clear();
      }

      const shouldSkipScrollback = options.skipScrollback === true;
      if (term && !shouldSkipScrollback) {
        term.clear();
        writeTerminalCache(terminalId, '');
      }
      closeSocket();

      const wsUrl = `${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.host}/ws?terminal_id=${encodeURIComponent(terminalId)}&skip_scrollback=${shouldSkipScrollback ? 'true' : 'false'}`;
      const connectionId = ++wsConnectionId;
      ws = new WebSocket(wsUrl);
      const localWs = ws;
      ws.binaryType = 'arraybuffer';

      ws.onopen = () => {
        if (connectionId !== wsConnectionId) return;
        retries = 0;
        setStatus(`Connected: ${terminalId}`, '#4caf50');
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'resize', cols: term.cols, rows: term.rows }));
        }
      };

      ws.onmessage = (e) => {
        if (connectionId !== wsConnectionId) return;
        if (typeof e.data === 'string') {
          const msg = JSON.parse(e.data);
          if (msg.type === 'session_expired') {
            showLogin('Session expired. Please login again.');
          }
        } else {
          const bytes = new Uint8Array(e.data);
          const chunkText = textDecoder.decode(bytes);
          appendTerminalCache(terminalId, chunkText);
          term.write(bytes);
        }
      };

      ws.onclose = async () => {
        if (connectionId !== wsConnectionId) return;
        if (ws !== localWs) {
          return;
        }
        if (terminalId !== activeTerminalId) {
          return;
        }
        if (loggingOut) {
          const notice = logoutNotice || 'Logged out.';
          loggingOut = false;
          logoutNotice = '';
          showLogin(notice);
          return;
        }

        const activeSession = await hasActiveSession();
        if (!activeSession) {
          showLogin('Session expired. Please login again.');
          return;
        }

        if (retries < 4) {
          retries++;
          setStatus(`Reconnecting (${retries})...`, '#ff9800');
          setTimeout(() => connectTerminal(terminalId, { skipScrollback: false }), 600 * retries);
        } else {
          setStatus('Disconnected', '#ff9800');
        }
      };

      ws.onerror = () => {
        if (connectionId !== wsConnectionId) return;
        ws.close();
      };
    }

    async function authorize(password, pin) {
      return api('/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password, pin })
      });
    }

    async function logout(revokeAll) {
      await api('/auth/logout', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ revoke_all: revokeAll })
      });
    }

    function setTempLinksModal(open) {
      if (open) {
        shareModal.classList.add('open');
        refreshTempLinks();
        if (tempLinksRefreshTimer) clearInterval(tempLinksRefreshTimer);
        tempLinksRefreshTimer = setInterval(() => renderTempLinks(), 1000);
      } else {
        shareModal.classList.remove('open');
        if (tempLinksRefreshTimer) {
          clearInterval(tempLinksRefreshTimer);
          tempLinksRefreshTimer = null;
        }
      }
    }

    function renderTempLinks() {
      tempLinksListEl.innerHTML = '';
      if (tempLinks.length === 0) {
        tempLinksListEl.textContent = 'No active temporary links.';
        return;
      }
      const now = Math.floor(Date.now() / 1000);
      for (const item of tempLinks) {
        const row = document.createElement('div');
        row.className = 'temp-link-item';
        const remaining = Math.max(0, (item.expires_at_unix || 0) - now);
        row.innerHTML = `
          <div><strong>${item.id}</strong> â€¢ ${item.scope}</div>
          <div class="meta">Uses ${item.used_count}/${item.max_uses} â€¢ Expires in ${formatSeconds(remaining)}${item.bound_terminal_id ? ` â€¢ tab ${item.bound_terminal_id}` : ''}</div>
        `;
        const actions = document.createElement('div');
        actions.className = 'actions';
        const revokeBtn = document.createElement('button');
        revokeBtn.className = 'ghost';
        revokeBtn.textContent = 'Revoke';
        revokeBtn.onclick = async () => {
          const res = await api(`/auth/temp-links/${encodeURIComponent(item.id)}`, { method: 'DELETE' });
          if (res.status === 204) {
            await refreshTempLinks();
          }
        };
        actions.appendChild(revokeBtn);
        row.appendChild(actions);
        tempLinksListEl.appendChild(row);
      }
    }

    async function refreshTempLinks() {
      const res = await api('/auth/temp-links');
      if (!res.ok) {
        tempLinks = [];
        renderTempLinks();
        return;
      }
      tempLinks = await res.json();
      renderTempLinks();
    }

    async function createTempLink() {
      const oneTime = tempOneTimeEl.checked;
      const payload = {
        ttl_minutes: Number(tempTtlEl.value || 15),
        scope: tempScopeEl.value,
        one_time: oneTime,
        max_uses: oneTime ? 1 : Number(tempMaxUsesEl.value || 5),
        bound_terminal_id: tempBindTerminalEl.checked ? activeTerminalId : null
      };
      const res = await api('/auth/temp-links', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const msg = await res.text();
        alert(msg || 'Failed to create temporary link');
        return;
      }
      const created = await res.json();
      shareLinkOutputEl.textContent = `${location.origin}${created.url}`;
      await navigator.clipboard?.writeText(`${location.origin}${created.url}`).catch(() => {});
      await refreshTempLinks();
    }

    async function loadTerminals() {
      const res = await api('/api/terminals');
      if (!res.ok) throw new Error('failed terminals');
      terminals = await res.json();
      if (terminals.length === 0) {
        await createTerminal('.');
      }
      renderTerminalTabs();
      if (!activeTerminalId || !terminals.some((t) => t.id === activeTerminalId)) {
        connectTerminal(terminals[0].id);
      }
    }

    async function createTerminal(cwd) {
      if (sessionAccess.readOnly || sessionAccess.boundTerminalId) {
        alert('This session cannot create terminal tabs.');
        return null;
      }
      const res = await api('/api/terminals', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ cwd: cwd || '.' })
      });
      if (!res.ok) {
        const msg = await res.text();
        alert(msg || 'Cannot create terminal');
        return null;
      }
      const item = await res.json();
      terminals.push(item);
      renderTerminalTabs();
      connectTerminal(item.id);
      selectedDir = cwd || '.';
      return item;
    }

    async function deleteTerminal(id) {
      if (sessionAccess.readOnly || sessionAccess.boundTerminalId) {
        alert('This session cannot close terminal tabs.');
        return;
      }
      const res = await api(`/api/terminals/${encodeURIComponent(id)}`, { method: 'DELETE' });
      if (res.status !== 204) {
        alert('Cannot close terminal');
        return;
      }
      try {
        localStorage.removeItem(termCacheKey(id));
      } catch {
        // ignore local cache failures
      }
      terminalCache.delete(id);
      terminals = terminals.filter((t) => t.id !== id);
      if (activeTerminalId === id) {
        if (terminals.length === 0) {
          await createTerminal(selectedDir || '.');
        } else {
          connectTerminal(terminals[0].id);
        }
      }
      renderTerminalTabs();
    }

    function moveTerminalTab(index, delta) {
      const next = index + delta;
      if (index < 0 || next < 0 || index >= terminals.length || next >= terminals.length) return;
      const temp = terminals[index];
      terminals[index] = terminals[next];
      terminals[next] = temp;
      renderTerminalTabs();
    }

    async function renameTerminal(id, title) {
      if (sessionAccess.readOnly || sessionAccess.boundTerminalId) {
        alert('This session cannot rename terminal tabs.');
        return null;
      }
      const res = await api(`/api/terminals/${encodeURIComponent(id)}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title })
      });
      if (!res.ok) {
        const msg = await res.text();
        alert(msg || 'Cannot rename terminal');
        return null;
      }
      return res.json();
    }

    async function promptRenameTerminal(item) {
      const next = window.prompt('Rename tab', item.title);
      if (next === null) return;
      const title = next.trim();
      if (!title || title === item.title) return;
      const updated = await renameTerminal(item.id, title);
      if (!updated) return;
      const idx = terminals.findIndex((t) => t.id === item.id);
      if (idx >= 0) terminals[idx] = updated;
      renderTerminalTabs();
    }

    function renderTerminalTabs() {
      termTabs.querySelectorAll('.tab').forEach((node) => node.remove());
      terminals.forEach((item, index) => {
        const tab = document.createElement('div');
        tab.className = `tab ${item.id === activeTerminalId ? 'active' : ''}`;
        tab.onclick = () => connectTerminal(item.id);

        const title = document.createElement('span');
        title.className = 'title';
        title.textContent = item.title;

        const leftBtn = document.createElement('button');
        leftBtn.className = 'icon-btn';
        leftBtn.textContent = 'â†';
        leftBtn.disabled = index === 0;
        leftBtn.onclick = (e) => {
          e.stopPropagation();
          moveTerminalTab(index, -1);
        };
        tab.appendChild(leftBtn);

        const rightBtn = document.createElement('button');
        rightBtn.className = 'icon-btn';
        rightBtn.textContent = 'â†’';
        rightBtn.disabled = index === terminals.length - 1;
        rightBtn.onclick = (e) => {
          e.stopPropagation();
          moveTerminalTab(index, 1);
        };
        tab.appendChild(title);
        tab.appendChild(rightBtn);

        const closeBtn = document.createElement('button');
        closeBtn.className = 'icon-btn';
        closeBtn.textContent = 'x';
        closeBtn.onclick = (e) => {
          e.stopPropagation();
          deleteTerminal(item.id);
        };
        tab.appendChild(closeBtn);
        termTabs.appendChild(tab);
      });
    }

    async function fetchTree(path) {
      const res = await api(`/api/fs/tree?path=${encodeURIComponent(path)}`);
      if (!res.ok) return null;
      return res.json();
    }

    async function fetchFile(path) {
      const res = await api(`/api/fs/file?path=${encodeURIComponent(path)}`);
      if (!res.ok) return null;
      return res.json();
    }

    function parentPath(path) {
      if (!path || path === '.') return '.';
      const idx = path.lastIndexOf('/');
      if (idx <= 0) return '.';
      return path.slice(0, idx);
    }

    function movePreviewTab(index, delta) {
      const next = index + delta;
      if (index < 0 || next < 0 || index >= openFiles.length || next >= openFiles.length) return;
      const temp = openFiles[index];
      openFiles[index] = openFiles[next];
      openFiles[next] = temp;
      renderPreviewTabs();
    }

    function renderPreviewTabs() {
      previewTabsEl.innerHTML = '';
      if (openFiles.length === 0) {
        activeFilePath = null;
        previewEl.textContent = 'Select a file to preview';
        updateEditorActionState();
        return;
      }
      openFiles.forEach((file, index) => {
        const tab = document.createElement('div');
        tab.className = `preview-tab ${file.path === activeFilePath ? 'active' : ''}`;

        const leftBtn = document.createElement('button');
        leftBtn.className = 'close';
        leftBtn.textContent = 'â†';
        leftBtn.disabled = index === 0;
        leftBtn.onclick = (e) => {
          e.stopPropagation();
          movePreviewTab(index, -1);
        };
        tab.appendChild(leftBtn);

        const label = document.createElement('button');
        label.className = 'label';
        label.textContent = file.path.split('/').pop();
        label.onclick = () => {
          activeFilePath = file.path;
          editingPath = null;
          editingBaseHash = null;
          editingOriginal = '';
          editorEl.style.display = 'none';
          previewEl.style.display = 'block';
          previewEl.textContent = file.content + (file.truncated ? '\n\n[truncated]' : '');
          renderPreviewTabs();
          updateEditorActionState();
        };
        tab.appendChild(label);

        const rightBtn = document.createElement('button');
        rightBtn.className = 'close';
        rightBtn.textContent = 'â†’';
        rightBtn.disabled = index === openFiles.length - 1;
        rightBtn.onclick = (e) => {
          e.stopPropagation();
          movePreviewTab(index, 1);
        };
        tab.appendChild(rightBtn);

        const closeBtn = document.createElement('button');
        closeBtn.className = 'close';
        closeBtn.textContent = 'x';
        closeBtn.onclick = (e) => {
          e.stopPropagation();
          const idx = openFiles.findIndex((item) => item.path === file.path);
          if (idx >= 0) {
            openFiles.splice(idx, 1);
          }
          if (activeFilePath === file.path) {
            const fallback = openFiles[idx] || openFiles[idx - 1];
            if (fallback) {
              activeFilePath = fallback.path;
              previewEl.textContent = fallback.content + (fallback.truncated ? '\n\n[truncated]' : '');
            } else {
              activeFilePath = null;
              previewEl.textContent = 'Select a file to preview';
            }
          }
          renderPreviewTabs();
          updateEditorActionState();
        };
        tab.appendChild(closeBtn);
        previewTabsEl.appendChild(tab);
      });
      updateEditorActionState();
    }

    async function openFile(path) {
      const meta = fileMeta.get(path);
      if (meta && typeof meta.size_bytes === 'number') {
        if (meta.size_bytes > FILE_EDIT_LIMIT_BYTES) {
          alert('File is too large to open in web preview/editor.');
          return;
        }
        if (meta.size_bytes > FILE_WARN_BYTES) {
          const proceed = window.confirm(`This file is ${formatBytes(meta.size_bytes)} and may use more data. Open anyway?`);
          if (!proceed) return;
        }
      }

      const cached = readFileCache(path, meta ? meta.size_bytes : undefined);
      if (cached) {
        const existingCached = openFiles.find((item) => item.path === cached.path);
        if (!existingCached) {
          openFiles.push(cached);
        } else {
          existingCached.content = cached.content;
          existingCached.truncated = cached.truncated;
          existingCached.hash = cached.hash;
          existingCached.size_bytes = cached.size_bytes;
        }
        activeFilePath = cached.path;
        editingPath = null;
        editingBaseHash = null;
        editingOriginal = '';
        editorEl.style.display = 'none';
        previewEl.style.display = 'block';
        previewEl.textContent = cached.content + (cached.truncated ? '\n\n[truncated]' : '');
        renderPreviewTabs();
        selectedDir = parentPath(cached.path);
        updateEditorActionState();
        return;
      }

      const file = await fetchFile(path);
      if (!file) return;
      const existing = openFiles.find((item) => item.path === file.path);
      if (!existing) {
        openFiles.push(file);
      } else {
        existing.content = file.content;
        existing.truncated = file.truncated;
        existing.hash = file.hash;
        existing.size_bytes = file.size_bytes;
      }
      writeFileCache(file);
      activeFilePath = file.path;
      editingPath = null;
      editingBaseHash = null;
      editingOriginal = '';
      editorEl.style.display = 'none';
      previewEl.style.display = 'block';
      previewEl.textContent = file.content + (file.truncated ? '\n\n[truncated]' : '');
      renderPreviewTabs();
      selectedDir = parentPath(file.path);
      updateEditorActionState();
    }

    async function saveActiveFile() {
      if (!editingPath) return;
      if (sessionAccess.readOnly) {
        alert('Read-only session cannot save files.');
        return;
      }
      const content = editorEl.value;
      const patch = computePatch(editingOriginal, content);
      const res = await api('/api/fs/file/diff', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          path: editingPath,
          base_hash: editingBaseHash,
          start: patch.start,
          delete_count: patch.delete_count,
          insert_text: patch.insert_text
        })
      });
      if (!res.ok) {
        const msg = await res.text();
        alert(msg || 'Cannot save file');
        return;
      }
      const saved = await res.json();
      const existing = openFiles.find((item) => item.path === editingPath);
      if (existing) {
        existing.content = content;
        existing.truncated = false;
        existing.hash = saved.hash;
        existing.size_bytes = saved.size_bytes;
        writeFileCache(existing);
      }
      previewEl.textContent = content;
      editingPath = null;
      editingBaseHash = null;
      editingOriginal = '';
      editorEl.style.display = 'none';
      previewEl.style.display = 'block';
      await renderTree();
      await refreshUsage();
      updateEditorActionState();
    }

    async function renderTree() {
      treeEl.innerHTML = '';
      fileMeta.clear();
      const root = await fetchTree('.');
      if (!root) {
        treeEl.textContent = 'Failed to load file tree';
        return;
      }

      const renderNodes = async (container, path, ancestry) => {
        const tree = await fetchTree(path);
        if (!tree) return;
        for (let i = 0; i < tree.entries.length; i++) {
          const entry = tree.entries[i];
          fileMeta.set(entry.path, entry);
          const isLast = i === tree.entries.length - 1;
          const row = document.createElement('div');
          row.className = 'tree-item';
          if (entry.path === selectedDir) {
            row.classList.add('active');
          }
          const expanded = expandedDirs.has(entry.path);
          const icon = entry.is_dir ? (expanded ? 'ðŸ“‚' : 'ðŸ“') : 'ðŸ“„';
          const toggle = entry.is_dir ? (expanded ? 'â–¾' : 'â–¸') : ' ';
          const guides = ancestry.map((hasNext) => (hasNext ? 'â”‚  ' : '   ')).join('');
          const branch = isLast ? 'â””â”€ ' : 'â”œâ”€ ';
          row.textContent = `${guides}${branch}${toggle} ${icon} ${entry.name}`;
          container.appendChild(row);

          if (entry.is_dir) {
            row.onclick = async () => {
              selectedDir = entry.path;
              if (expandedDirs.has(entry.path)) {
                expandedDirs.delete(entry.path);
              } else {
                expandedDirs.add(entry.path);
              }
              await renderTree();
            };
            if (expanded) {
              const next = document.createElement('div');
              next.className = 'indent';
              row.after(next);
              await renderNodes(next, entry.path, [...ancestry, !isLast]);
            }
          } else {
            row.onclick = () => openFile(entry.path);
          }
        }
      };

      await renderNodes(treeEl, '.', []);
    }

    async function bootstrapWorkspace() {
      initTerminal();
      login.style.display = 'none';
      app.style.display = 'flex';
      try {
        const caps = await api('/api/capabilities');
        if (caps && caps.terminal_only) {
          document.body.classList.add('terminal-only');
        }
      } catch {}
      setLoginPolling(false);
      await Promise.all([loadTerminals(), renderTree()]);
      await refreshUsage();
      await refreshSessionWarning();
      setSessionPolling(true);
      if (usageTimer) {
        clearInterval(usageTimer);
      }
      usageTimer = setInterval(refreshUsage, 20000);
      if (fitAddon) fitAddon.fit();
    }

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const password = passwordInput.value;
      const pin = pinInput.value.trim() || null;
      errorEl.textContent = '';
      submitBtn.disabled = true;

      try {
        const res = await authorize(password, pin);
        if (!res.ok) {
          if (res.status === 423) {
            errorEl.textContent = 'Access locked. Restart CodeWebway to login again.';
          } else if (res.status === 429) {
            errorEl.textContent = 'Too many attempts. Try again later.';
          } else {
            errorEl.textContent = 'Invalid token or PIN';
          }
          submitBtn.disabled = false;
          return;
        }
      } catch {
        errorEl.textContent = 'Cannot reach server';
        submitBtn.disabled = false;
        return;
      }

      submitBtn.disabled = false;
      await bootstrapWorkspace();
    });

    newTabBtn.addEventListener('click', () => createTerminal(selectedDir || '.'));

    openShellHereBtn.addEventListener('click', () => createTerminal(selectedDir || '.'));
    refreshTreeBtn.addEventListener('click', () => renderTree());

    editFileBtn.addEventListener('click', () => {
      if (!activeFilePath) return;
      const current = openFiles.find((item) => item.path === activeFilePath);
      if (!current) return;
      if (current.truncated) {
        alert('File is truncated in preview. Open a smaller file to edit.');
        return;
      }
      if ((current.size_bytes || current.content.length) > FILE_EDIT_LIMIT_BYTES) {
        alert('File is too large to edit in-browser.');
        return;
      }
      editingPath = current.path;
      editingBaseHash = current.hash;
      editingOriginal = current.content;
      editorEl.value = current.content;
      previewEl.style.display = 'none';
      editorEl.style.display = 'block';
      editorEl.focus();
      updateEditorActionState();
    });

    saveFileBtn.addEventListener('click', () => {
      saveActiveFile();
    });

    cancelEditBtn.addEventListener('click', () => {
      editingPath = null;
      editingBaseHash = null;
      editingOriginal = '';
      editorEl.style.display = 'none';
      previewEl.style.display = 'block';
      updateEditorActionState();
    });

    editorEl.addEventListener('keydown', (e) => {
      if (e.key === 'Tab') {
        e.preventDefault();
        const text = editorEl.value;
        const start = editorEl.selectionStart;
        const end = editorEl.selectionEnd;
        const hasSelection = end > start;

        if (!e.shiftKey) {
          if (!hasSelection) {
            editorEl.value = `${text.slice(0, start)}  ${text.slice(end)}`;
            editorEl.selectionStart = editorEl.selectionEnd = start + 2;
            return;
          }

          const startLine = lineStartIndex(text, start);
          const endLine = lineEndIndex(text, end);
          const block = text.slice(startLine, endLine);
          const indented = block
            .split('\n')
            .map((line) => `  ${line}`)
            .join('\n');
          editorEl.value = `${text.slice(0, startLine)}${indented}${text.slice(endLine)}`;
          editorEl.selectionStart = start + 2;
          editorEl.selectionEnd = end + (2 * block.split('\n').length);
          return;
        }

        const startLine = lineStartIndex(text, start);
        const endLine = lineEndIndex(text, end);
        const lines = text.slice(startLine, endLine).split('\n');
        let removed = 0;
        const outdented = lines.map((line) => {
          if (line.startsWith('  ')) {
            removed += 2;
            return line.slice(2);
          }
          if (line.startsWith('\t')) {
            removed += 1;
            return line.slice(1);
          }
          return line;
        }).join('\n');
        editorEl.value = `${text.slice(0, startLine)}${outdented}${text.slice(endLine)}`;

        if (!hasSelection) {
          const caretShift = lines[0].startsWith('  ') ? 2 : (lines[0].startsWith('\t') ? 1 : 0);
          const next = Math.max(start - caretShift, startLine);
          editorEl.selectionStart = editorEl.selectionEnd = next;
        } else {
          const firstShift = lines[0].startsWith('  ') ? 2 : (lines[0].startsWith('\t') ? 1 : 0);
          editorEl.selectionStart = Math.max(start - firstShift, startLine);
          editorEl.selectionEnd = Math.max(editorEl.selectionStart, end - removed);
        }
        return;
      }

      if (e.key === 'Enter') {
        e.preventDefault();
        const text = editorEl.value;
        const start = editorEl.selectionStart;
        const end = editorEl.selectionEnd;
        const currentLineStart = lineStartIndex(text, start);
        const beforeCaret = text.slice(currentLineStart, start);
        const indent = (beforeCaret.match(/^[\t ]*/) || [''])[0];
        const insert = `\n${indent}`;
        editorEl.value = `${text.slice(0, start)}${insert}${text.slice(end)}`;
        const nextPos = start + insert.length;
        editorEl.selectionStart = editorEl.selectionEnd = nextPos;
      }
    });

    logoutBtn.addEventListener('click', async () => {
      const lockSystem = await chooseLogoutMode();
      if (lockSystem === null) return;
      loggingOut = true;
      logoutNotice = lockSystem
        ? 'Lockout enabled. Server is shutting down now.'
        : 'Logged out.';

      await logout(lockSystem);
      closeSocket();
      terminals.forEach((t) => {
        try {
          localStorage.removeItem(termCacheKey(t.id));
        } catch {
          // ignore local cache failures
        }
      });
      terminalCache.clear();
      showLogin(logoutNotice);
      loggingOut = false;
      logoutNotice = '';
      if (usageTimer) {
        clearInterval(usageTimer);
        usageTimer = null;
      }
      setSessionPolling(false);
      setLoginPolling(true);
    });

    if (shareBtn) {
      shareBtn.addEventListener('click', async () => {
        if (shareBtn.disabled) return;
        shareLinkOutputEl.textContent = '';
        await refreshTempLinks();
        setTempLinksModal(true);
      });
    }

    shareCloseBtn.addEventListener('click', () => setTempLinksModal(false));
    shareModal.addEventListener('click', (e) => {
      if (e.target === shareModal) setTempLinksModal(false);
    });

    createTempLinkBtn.addEventListener('click', () => createTempLink());
    tempOneTimeEl.addEventListener('change', () => {
      tempMaxUsesEl.disabled = tempOneTimeEl.checked;
    });
    tempMaxUsesEl.disabled = tempOneTimeEl.checked;

    staySignedInBtn.addEventListener('click', async () => {
      const pin = window.prompt('Confirm PIN to extend session:');
      if (pin === null) return;
      const res = await extendSession(pin.trim());
      if (!res.ok) {
        alert('PIN invalid or session expired.');
        return;
      }
      hideSessionWarning();
      await refreshSessionWarning();
    });

    updateEditorActionState();
    setLoginPolling(true);
  </script>
</body>
</html>
